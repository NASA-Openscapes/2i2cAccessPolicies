---
title: "NASA Openscapes Jupyter Hub Storage Usage and Costs"
format: html
---

```{r}
#| echo: false
get_default_prometheus_uid <- function(grafana_url = "https://grafana.openscapes.2i2c.cloud",
                                       grafana_token = Sys.getenv("GRAFANA_TOKEN")) {
  api_url <- glue::glue("{grafana_url}/")

  res <- httr2::request(grafana_url) |> 
    httr2::req_url_path("/api/datasources/") |> 
    httr2::req_auth_bearer_token(grafana_token) |> 
    httr2::req_perform()

  body <- httr2::resp_body_json(res)

  Filter(\(x) x$name == "prometheus", body)[[1]][["uid"]] # should also check if isDefault, but there is only one and it is isDefault = FALSE
}
 
#  get_homedir_dashboard <- function(
#     grafana_url = "https://grafana.openscapes.2i2c.cloud",
#     grafana_token = Sys.getenv("GRAFANA_TOKEN")
#   ) {
#     ret <- httr2::request(grafana_url) |> 
#       httr2::req_url_path("/api/dashboards/uid", "bd232539-52d0-4435-8a62-fe637dc822be") |> 
#       httr2::req_auth_bearer_token(grafana_token) |> 
#       httr2::req_perform() |> 
#       httr2::resp_check_status() |> 
#       httr2::resp_body_json()
  
#     ret
#   }

query_prometheus_range <- function(
  grafana_url = "https://grafana.openscapes.2i2c.cloud",
  grafana_token = Sys.getenv("GRAFANA_TOKEN"),
  prometheus_uid = get_default_prometheus_uid(grafana_url, grafana_token),
  query,
  start_time,
  end_time,
  step
) {
  
  # Query data from prometheus & return responses
# 
  # Args:
  #     grafana_url (str): URL of Grafana to use to query. Must end in a trailing slash
  #     grafana_token (str): Token of grafana service account with Viewer permissions to use
  #     prometheus_uid (str): uid of prometheus datasource within grafana to query
  #     query (str): Prometheus query to execute
  #     start_time (datetime): Start time to run this query from
  #     end_time (datetime): End time to run this query till
  #     step (int): Steps (in seconds) to execute this query, starting from start_time until end_time
# 
  # Returns:
  #     Query responses, in the [range vector format](https://prometheus.io/docs/prometheus/latest/querying/api/#range-vectors)
  #     [
  #         {"metric": {<metric-info>}, "values": [[timestamp, value], [timestamp, value]...]},
  #         {"metric": {<metric-info>}, "values": [[timestamp, value], [timestamp, value]...]}
  #     ]

  httr2::request(grafana_url) |> 
    httr2::req_url_path("/api/datasources/proxy/uid", prometheus_uid, "api/v1/query_range") |> 
    httr2::req_auth_bearer_token(grafana_token) |> 
    httr2::req_url_query(
      query = query,
      start = format(as.POSIXct(start_time), "%Y-%m-%dT%H:%M:%SZ"),
      end = format(as.POSIXct(end_time), "%Y-%m-%dT%H:%M:%SZ"),
      step = step
      ) |> 
    httr2::req_perform() |> 
    httr2::resp_check_status() |> 
    httr2::resp_body_json(simplifyVector = TRUE, simplifyDataFrame = TRUE)

} 


query_prometheus_static <- function(
  grafana_url = "https://grafana.openscapes.2i2c.cloud",
  grafana_token = Sys.getenv("GRAFANA_TOKEN"),
  prometheus_uid = get_default_prometheus_uid(grafana_url, grafana_token),
  query
) {
  
  # Query data from prometheus & return responses
# 
  # Args:
  #     grafana_url (str): URL of Grafana to use to query. Must end in a trailing slash
  #     grafana_token (str): Token of grafana service account with Viewer permissions to use
  #     prometheus_uid (str): uid of prometheus datasource within grafana to query
  #     query (str): Prometheus query to execute

# 
  # Returns:
  #     Query responses, in the [instant vector format](https://prometheus.io/docs/prometheus/latest/querying/api/#range-vectors)
  #     
  #     [
  #       {
  #         "metric": { "<label_name>": "<label_value>", ... },
  #         "value": [ <unix_time>, "<sample_value>" ],
  #         "histogram": [ <unix_time>, <histogram> ]
  #       },
  #       ...
  #     ]

  httr2::request(grafana_url) |> 
    httr2::req_url_path("/api/datasources/proxy/uid", prometheus_uid, "api/v1/query") |> 
    httr2::req_auth_bearer_token(grafana_token) |> 
    httr2::req_url_query(
      query = query
      ) |> 
    httr2::req_perform() |> 
    httr2::resp_check_status() |> 
    httr2::resp_body_json(simplifyVector = TRUE)

}



```

```{r}
library(dplyr)
library(kyber)
library(ggplot2)
library(forcats)

current_size <- query_prometheus_static(
  query = "max(dirsize_total_size_bytes) by (directory)"
  )

size_by_date <- query_prometheus_range(
  query = "max(dirsize_total_size_bytes) by (directory)",
  start_time = "2024-01-01",
  end_time = "2024-05-28",
  step = 60 * 60 *24
)

dirs <- size_by_date$data$result$metric$directory
vals <- size_by_date$data$result$values

df <- lapply(seq_along(vals), \(x) {
  vals <- as.data.frame(vals[[x]])
  vals$dir <- dirs[x]
  vals
 }) |> 
  dplyr::bind_rows() |> 
  rename(date = V1, size = V2) |> 
  mutate(
    date = as.POSIXct(as.numeric(date), origin = "1970-01-01", tz = "UTC"), 
    size = as.numeric(size) * 9.3132257461548e-10,
    username = gsub("-2d", "-", dir)
  )

team_members <- list_team_members(
  team = "nasa-champions-2024", 
  org = "nasa-openscapes-workshops",
  names_only = TRUE
  ) |> 
    tolower()

setdiff(team_members, unique(df$username))

champs_df <- filter(
  df, 
  username %in% team_members, 
  date >= as.Date("2024-04-01"),
  !username %in% unique(df$username[df$date <= as.Date("2024-03-31")])
) |> 
  mutate(username = fct_reorder(username, desc(size), .fun = max, .desc = TRUE))

df_sum_by_date <- df |> 
  group_by(date) |> 
  summarize(total_size_gb = sum(size))

ggplot(df_sum_by_date, aes(x = date, y = total_size_gb)) + 
  geom_area(fill = "#9D4076") + 
  labs(x = "Date", y = "Size (GiB)") + 
  theme_classic()

ggplot(champs_df, aes(x = date, y = size, fill = username)) + 
  geom_area() + 
  paletteer::scale_fill_paletteer_d("khroma::soil", guide = FALSE) + 
    geom_vline(xintercept = as.Date("2024-04-17"), colour = "black") + 
    labs(x = "Date", y = "Size (GiB)") + 
    theme_classic()

```
