---
title: "NASA Openscapes Jupyter Hub Storage Usage and Costs"
format: html
---

```{r}
#| echo: false
get_default_prometheus_uid <- function(grafana_url = "https://grafana.openscapes.2i2c.cloud",
                                       grafana_token = Sys.getenv("GRAFANA_TOKEN")) {
  api_url <- glue::glue("{grafana_url}/")

  res <- httr2::request(grafana_url) |>
    httr2::req_url_path("/api/datasources/") |>
    httr2::req_auth_bearer_token(grafana_token) |>
    httr2::req_perform()

  body <- httr2::resp_body_json(res)

  Filter(\(x) x$name == "prometheus", body)[[1]][["uid"]] # should also check if isDefault, but there is only one and it is isDefault = FALSE
}

#  get_homedir_dashboard <- function(
#     grafana_url = "https://grafana.openscapes.2i2c.cloud",
#     grafana_token = Sys.getenv("GRAFANA_TOKEN")
#   ) {
#     ret <- httr2::request(grafana_url) |>
#       httr2::req_url_path("/api/dashboards/uid", "bd232539-52d0-4435-8a62-fe637dc822be") |>
#       httr2::req_auth_bearer_token(grafana_token) |>
#       httr2::req_perform() |>
#       httr2::resp_check_status() |>
#       httr2::resp_body_json()

#     ret
#   }

query_prometheus_range <- function(
    grafana_url = "https://grafana.openscapes.2i2c.cloud",
    grafana_token = Sys.getenv("GRAFANA_TOKEN"),
    prometheus_uid = get_default_prometheus_uid(grafana_url, grafana_token),
    query,
    start_time,
    end_time,
    step) {
  # Query data from prometheus & return responses
  #
  # Args:
  #     grafana_url (str): URL of Grafana to use to query. Must end in a trailing slash
  #     grafana_token (str): Token of grafana service account with Viewer permissions to use
  #     prometheus_uid (str): uid of prometheus datasource within grafana to query
  #     query (str): Prometheus query to execute
  #     start_time (datetime): Start time to run this query from
  #     end_time (datetime): End time to run this query till
  #     step (int): Steps (in seconds) to execute this query, starting from start_time until end_time
  #
  # Returns:
  #     Query responses, in the [range vector format](https://prometheus.io/docs/prometheus/latest/querying/api/#range-vectors)
  #     [
  #         {"metric": {<metric-info>}, "values": [[timestamp, value], [timestamp, value]...]},
  #         {"metric": {<metric-info>}, "values": [[timestamp, value], [timestamp, value]...]}
  #     ]

  httr2::request(grafana_url) |>
    httr2::req_url_path("/api/datasources/proxy/uid", prometheus_uid, "api/v1/query_range") |>
    httr2::req_auth_bearer_token(grafana_token) |>
    httr2::req_url_query(
      query = query,
      start = format(as.POSIXct(start_time), "%Y-%m-%dT%H:%M:%SZ"),
      end = format(as.POSIXct(end_time), "%Y-%m-%dT%H:%M:%SZ"),
      step = step
    ) |>
    httr2::req_perform() |>
    httr2::resp_check_status() |>
    httr2::resp_body_json(simplifyVector = TRUE, simplifyDataFrame = TRUE)
}


query_prometheus_static <- function(
    grafana_url = "https://grafana.openscapes.2i2c.cloud",
    grafana_token = Sys.getenv("GRAFANA_TOKEN"),
    prometheus_uid = get_default_prometheus_uid(grafana_url, grafana_token),
    query) {
  # Query data from prometheus & return responses
  #
  # Args:
  #     grafana_url (str): URL of Grafana to use to query. Must end in a trailing slash
  #     grafana_token (str): Token of grafana service account with Viewer permissions to use
  #     prometheus_uid (str): uid of prometheus datasource within grafana to query
  #     query (str): Prometheus query to execute

  #
  # Returns:
  #     Query responses, in the [instant vector format](https://prometheus.io/docs/prometheus/latest/querying/api/#range-vectors)
  #
  #     [
  #       {
  #         "metric": { "<label_name>": "<label_value>", ... },
  #         "value": [ <unix_time>, "<sample_value>" ],
  #         "histogram": [ <unix_time>, <histogram> ]
  #       },
  #       ...
  #     ]

  httr2::request(grafana_url) |>
    httr2::req_url_path("/api/datasources/proxy/uid", prometheus_uid, "api/v1/query") |>
    httr2::req_auth_bearer_token(grafana_token) |>
    httr2::req_url_query(
      query = query
    ) |>
    httr2::req_perform() |>
    httr2::resp_check_status() |>
    httr2::resp_body_json(simplifyVector = TRUE)
}



```

```{r}
library(dplyr)
library(kyber)
library(ggplot2)
library(forcats)

current_size <- query_prometheus_static(
  query = "max(dirsize_total_size_bytes) by (directory)"
)

size_by_date <- query_prometheus_range(
  query = "max(dirsize_total_size_bytes) by (directory)",
  start_time = "2024-01-01",
  end_time = "2024-05-28",
  step = 60 * 60 * 24
)

dirs <- size_by_date$data$result$metric$directory
vals <- size_by_date$data$result$values

df <- lapply(seq_along(vals), \(x) {
  vals <- as.data.frame(vals[[x]])
  vals$dir <- dirs[x]
  vals
}) |>
  dplyr::bind_rows() |>
  rename(date = V1, size = V2) |>
  mutate(
    date = as.POSIXct(as.numeric(date), origin = "1970-01-01", tz = "UTC"),
    size = as.numeric(size) * 9.3132257461548e-10,
    username = gsub("-2d", "-", dir)
  )

team_members <- list_team_members(
  team = "nasa-champions-2024",
  org = "nasa-openscapes-workshops",
  names_only = TRUE
) |>
  tolower()

setdiff(team_members, unique(df$username))

champs_df <- filter(
  df,
  username %in% team_members,
  date >= as.Date("2024-04-01"),
  !username %in% unique(df$username[df$date <= as.Date("2024-03-31")])
) |>
  mutate(username = fct_reorder(username, desc(size), .fun = max, .desc = TRUE))

df_sum_by_date <- df |>
  group_by(date) |>
  summarize(total_size_gb = sum(size))

ggplot(df_sum_by_date, aes(x = date, y = total_size_gb)) +
  geom_area(fill = "#9D4076") +
  labs(x = "Date", y = "Size (GiB)") +
  theme_classic()

ggplot(champs_df, aes(x = date, y = size, fill = username)) +
  geom_area() +
  paletteer::scale_fill_paletteer_d("khroma::soil", guide = FALSE) +
  geom_vline(xintercept = as.Date("2024-04-17"), colour = "black") +
  labs(x = "Date", y = "Size (GiB)") +
  theme_classic()

```

```{r}
library(paws)

cost_explorer <- paws::costexplorer()

start_date <- format(Sys.Date() - 60)
end_date <- format(Sys.Date() + 1)

# https://www.paws-r-sdk.com/docs/costexplorer_get_cost_and_usage/
# https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_GetDimensionValues.html
res <- cost_explorer$get_cost_and_usage(
  TimePeriod = list(Start = start_date, End = end_date),
  Granularity = "DAILY",
  Filter = list(Dimensions = list(
    Key = "RECORD_TYPE",
    Values = "Usage"
  )),
  Metrics = "UnblendedCost",
  GroupBy = list(
    list(
      Type = "DIMENSION",
      Key = "SERVICE"
    ),
    list(
      Type = "DIMENSION",
      Key = "INSTANCE_TYPE"
    )
  )
)

ce_to_df <- function(ce_result) {
  dimension_names <- tolower(
    vapply(ce_result$GroupDefinitions, `[[`, "Key", FUN.VALUE = character(1))
  )

  df_list <- lapply(
    ce_result$ResultsByTime,
    results_by_time_to_df,
    keynames = dimension_names
  )

  purrr::list_rbind(df_list)
}

results_by_time_to_df <- function(x, keynames) {
  date <- as.Date(x$TimePeriod$Start)

  keys <- purrr::list_rbind(
    lapply(x$Groups, \(x) {
      as.data.frame(
        t(x[["Keys"]])
      )
    })
  )

  names(keys) <- keynames

  amount_usd <- vapply(
    x$Groups, \(x) {
      as.numeric(x$Metrics$UnblendedCost$Amount)
    },
    FUN.VALUE = numeric(1)
  )

  cbind(date, keys, amount_usd)
}

usage_costs <- ce_to_df(res)
```

```{r}
library(dplyr)
library(ggplot2)
library(forcats)

# Only include services where total cost for the time period > $1
services_to_ignore <- usage_costs |>
  group_by(service) |>
  summarise(total_cost = sum(amount_usd)) |>
  filter(total_cost < 1)

cost_by_service <- usage_costs |>
  anti_join(services_to_ignore, by = "service") |>
  group_by(date, service) |>
  summarize(
    cost = sum(amount_usd),
    .groups = "drop"
  ) |>
  arrange(date) |>
  mutate(
    cum_cost = cumsum(cost),
    .by = "service"
  ) |>
  mutate(
    service = fct_reorder(service, desc(cost), .fun = sum)
  )

ggplot(
  cost_by_service,
  aes(
    x = date, y = cost,
    fill = fct_reorder(service, desc(cost), .fun = sum, .desc = TRUE)
  )
) +
  geom_col() +
  paletteer::scale_fill_paletteer_d("ggpomological::pomological_palette", direction = -1) +
  guides(fill = guide_legend(nrow = 3)) +
  theme_classic() +
  theme(legend.position = "bottom", legend.title.position = "top") +
  labs(
    x = "Date",
    y = "Daily cost ($)",
    fill = "AWS Service"
  )

ggplot(cost_by_service, aes(x = date, y = cost, colour = service)) +
  geom_line() +
  facet_wrap(vars(service), scales = "free_y") +
  paletteer::scale_colour_paletteer_d("ggpomological::pomological_palette", direction = 1, guide = "none") +
  theme_classic()
```
